<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="../css/style.css">
    <link
        href="https://fonts.googleapis.com/css2?family=Merriweather&family=Varela+Round&family=Lato:ital@1&display=swap"
        rel="stylesheet">
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css">
    <title>Blog</title>
</head>

<body>
    <!-- nav bar -->
    <div class="nav">
        <a href=".." class="item"><i class="fa fa-server"></i>Ruoxuan's Website</a>
        <a href="../../projects/" class="item"><i class="fa fa-folder-open"></i>Projects</a>
        <a href="../../contact/" class="item"><i class="fa fa-paper-plane"></i>Contact</a>
        <a href="../../blog/" class="item current-page"><i class="fa fa-rss"></i>Blog</a>
    </div>
    <!-- nav bar -->


    <div class="content">
        <h1 class="center">Minimum Subset Sum Difference</h1>
        <h2>Problem</h2>
        <p>Given a set of positive numbers, partition the set into two subsets with a minimum difference between their
            subset sums. </p>
        <h2>Basic Solution</h2>
        <pre>
            <code>
            public int canPartition(int[] num) {
                return this.canPartitionRecursive(num, 0, 0, 0);
            }
            
            private int canPartitionRecursive(int[] num, int currentIndex, int sum1, int sum2) {
                if (currentIndex == num.length)
                    return Math.abs(sum1 - sum2);
                
                int diff1 = canPartitionRecursive(num, currentIndex+1, sum1+num[currentIndex], sum2);
                int diff2 = canPartitionRecursive(num, currentIndex+1, sum1, sum2+num[currentIndex]);
                return Math.min(diff1, diff2);
            }
        </code>
        </pre>
        <p>Time complexity: exponential O(2^n), n represents the total number</p>
        <p>Space complexity: O(n), which is used to store the recursive stack</p>
        <h2>Top-down Dynamic Programming with Memorization</h2>
        <p>Identify a sub-problem from currentIndex and Sum1; as Sum2 will always be the sum of the remaining numbers.
        </p>
        <pre>
            <code>
                public int canPartition(int[] num) {
                    int sum = 0;
                    for (int i = 0; i < num.length; i++)
                        sum += num[i];
                    int[][] dp = new int[num.length][sum+1];
                    return canPartitionRecursive(dp, num, 0, 0, 0);
                }
                
                // return minimum sum difference
                private int canPartitionRecursive(Integer[][] dp, int[] num, int currentIndex, int sum1, int sum2) {
                    if (currentIndex == num.length)
                        return Math.abs(sum1 - sum2);
                    if (dp[currentIndex][sum1] == null) {
                        int diff1 = canPartitionRecursive(dp, num, currentIndex + 1, sum1 + num[currentIndex], sum2);
                          int diff2 = canPartitionRecursive(dp, num, currentIndex + 1, sum1, sum2 + num[currentIndex]);
                        dp[currentIndex][sum1] = Math.min(diff1, diff2);
                    }
                    return dp[currentIndex][sum1];
                }
            </code>
        </pre>
        <h2>Bottom-up Dynamic Programming </h2>
        <p>Find a subset whose sum is as close to ‘S/2’ as possible. If we can’t find such a subset, then we will take
            the subset which has the sum closest to ‘S/2’.</p>
        <pre>
            <code>
                public int canPartiton(int[] num) {
                    int sum = 0;
                    for (int i = 0; i < num.length; i++)
                        sum += num[i];
                    int n = num.length;
                    boolean[][] dp = new boolean[n][sum/2+1];
                    
                    for (int i = 0; i < n; i++) {
                        dp[i][0] = true;
                    }
                    
                    for (int s = 1; s <= sum / 2; s++) {
                        dp[i][0] = (num[0] == s);
                    }
                    
                    for (int i = 1; i < n; i++) {
                        for (int s = 1; s <= sum / 2; s++) {
                            if (dp[i-1][s]) {
                                dp[i][s] = dp[i-1][s];
                            } else if (s >= num[i]) {
                                dp[i][s] = dp[i-1][s-num[i]];
                            }
                        }
                    }
                    
                    // // Find the largest index in the last row which is true
                    int sum1 = 0;
                    for (int i = sum/2; i >= 0; i--) {
                        if (dp[n-1][i] == true) {
                            sum1 = i;
                            break;
                        }
                    }
                    int sum2 = sum - sum1;
                    return Math.abs(sum2 - sum1);
                }
            </code>
        </pre>
        <p>Time Complexity: O(N*S)</p>
    </div>

</body>

</html>